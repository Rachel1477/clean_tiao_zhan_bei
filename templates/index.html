<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>雷达目标在线识别与可视化系统</title>
  <style>
    :root {
      --primary-color: #00ff00;
      /* 亮绿色 */
      --bg-color: #000000;
      --border-color: #008000;
      /* 暗绿色 */
      --text-color: #ffffff;
      --panel-bg-color: rgba(0, 0, 0, 0.6);
      --highlight-color: #ffff00;
      /* 黄色 */
      --error-color: #ff4444;
      /* 红色 */
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      width: 100vw;
      height: 100vh;
      background-color: var(--bg-color);
      color: var(--text-color);
      display: flex;
      font-family: 'Courier New', Courier, monospace;
      overflow: hidden;
    }

    /* 左侧雷达区域 */
    .radar-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      position: relative;
      padding: 20px;
    }

    #radar-canvas {
      width: 100%;
      height: 100%;
      max-width: 90vh;
      /* 保持宽高比 */
      max-height: 90vh;
      background-color: var(--bg-color);
      border: 1px solid var(--border-color);
      border-radius: 50%;
      cursor: crosshair;
    }

    /* 放大镜小窗 */
    #magnifier-canvas {
      position: absolute;
      width: 220px;
      height: 160px;
      border: 2px solid rgba(0, 255, 0, 0.9);
      border-radius: 6px;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.6);
      display: none;
      /* 激活后显示 */
      pointer-events: none;
      /* 不阻塞鼠标事件 */
      z-index: 50;
      background: #000;
    }

    /* 右侧信息区域 */
    .info-container {
      width: 560px;
      display: flex;
      flex-direction: column;
      padding: 10px;
      background-color: var(--panel-bg-color);
      border-left: 2px solid var(--border-color);
    }

    .control-panel,
    .path-panel {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      align-items: center; /* 垂直居中对齐 */
    }

    .control-panel button,
    .control-panel select,
    .control-panel input[type="range"],
    .path-panel button {
      padding: 8px;
      background: var(--bg-color);
      color: var(--primary-color);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      cursor: pointer;
      font-family: inherit;
      font-size: 14px;
    }
    
    .path-panel {
      flex-direction: column;
      align-items: stretch; /* 让内部元素撑满 */
    }

    .path-input-group {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .path-input-group label {
      font-size: 12px;
      flex-shrink: 0;
      width: 110px; /* 对齐 */
    }

    .path-input-group input[type="text"] {
      width: 100%;
      padding: 6px;
      background: #111;
      color: var(--text-color);
      border: 1px solid var(--border-color);
      font-size: 12px;
      font-family: inherit;
    }


    .control-panel .flex-item, .path-panel .flex-item {
      flex: 1;
    }

    .control-panel .small {
      flex: 0 0 110px;
    }

    .control-panel label {
        font-size: 14px;
        color: var(--primary-color);
        margin-right: -5px; /* 微调间距 */
    }

    .control-panel button:hover, .path-panel button:hover {
      background-color: var(--border-color);
    }

    .status-bar {
      padding: 8px;
      margin-bottom: 10px;
      background-color: rgba(0, 0, 0, 0.8);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      text-align: center;
      height: 40px;
      line-height: 22px;
      font-size: 14px;
    }

    .chart-box {
      flex: 1;
      margin-bottom: 10px;
      border: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
    }

    .chart-box h3 {
      margin-bottom: 10px;
      color: var(--primary-color);
      align-self: flex-start;
    }

    #scatter-canvas {
      width: 100%;
      height: 100%;
      background-color: var(--bg-color);
    }

    .table-box {
      flex: 1.2;
      border: 1px solid var(--border-color);
      padding: 10px;
      overflow-y: auto;
      /* 改为Y轴滚动 */
    }

    table {
      width: 100%;
      border-collapse: collapse;
    }

    th,
    td {
      border: 1px solid var(--border-color);
      text-align: center;
      padding: 5px;
      font-size: 12px;
    }

    th {
      background-color: rgba(0, 128, 0, 0.3);
      position: sticky;
      top: 0;
    }

    .slider-value {
      text-align: center;
      font-size: 12px;
      color: var(--primary-color);
    }
  </style>
</head>

<body>
  <a href="/training" target="_blank" style="position:absolute; top:10px; left: 10px; z-index:100; font-size: 1em; padding: 8px; background-color: #007bff; color: white; text-decoration: none; border-radius: 5px;">
     打开模型训练控制台
</a>
  <!-- 左侧雷达画布容器 -->
  <div class="radar-container">
    <canvas id="radar-canvas"></canvas>
    <!-- 放大镜画布（跟随鼠标的放大小窗） -->
    <canvas id="magnifier-canvas"></canvas>
  </div>

  <!-- 右侧信息容器 -->
  <div class="info-container">
    <div class="status-bar" id="statusBar">请先设置数据路径并扫描</div>
    <div class="path-panel">
        <div class="path-input-group">
            <label for="trainPathInput">训练数据根目录:</label>
            <input type="text" id="trainPathInput">
        </div>
        <div class="path-input-group">
            <label for="customerPathInput">测试数据根目录:</label>
            <input type="text" id="customerPathInput">
        </div>
        <button id="updatePathsButton" class="flex-item">更新路径并扫描</button>
    </div>
    <div class="control-panel">
        <label for="sourceSelect">数据源:</label>
        <select id="sourceSelect" class="flex-item" disabled><option value="">待扫描...</option></select>
        <label for="batchSelect">批号:</label>
        <select id="batchSelect" class="flex-item" disabled><option value="">请先选数据源</option></select>
    </div>
    <div class="control-panel">
      <button id="addButton" class="flex-item">添加轨迹到雷达</button>
      <button id="clearButton" class="flex-item">清除所有雷达轨迹</button>
    </div>
    <div class="control-panel">
      <div class="small" style="display:flex;flex-direction:column;align-items:center;">
        <label for="scaleRange">雷达比例尺</label>
        <input id="scaleRange" type="range" min="0.25" max="3" step="0.05" value="1">
        <div class="slider-value" id="scaleValue">缩放: 1.00×</div>
      </div>
      <div style="display:flex;flex-direction:column;justify-content:center; flex:1; text-align:center;">
        <div style="font-size:12px;color:var(--primary-color);">选中批号即时显示点迹与表格</div>
      </div>
    </div>
    <div class="chart-box">
      <h3>当前选中批号点迹 (距离-俯仰)</h3>
      <canvas id="scatter-canvas"></canvas>
    </div>
    <div class="table-box">
      <table id="track-table">
        <thead>
          <tr>
            <th>时间</th>
            <th>批号</th>
            <th>距离(m)</th>
            <th>方位(°)</th>
            <th>俯仰(°)</th>
            <th>速度(m/s)</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <script>
    // --- 全局变量和配置 ---
    const API_BASE = `${window.location.protocol}//${window.location.host}`;
    function getCSSVar(name) { return getComputedStyle(document.documentElement).getPropertyValue(name).trim() || ''; }
    let radarTracks = {}; let currentScatterData = []; let currentTableData = []; let radarZoom = 1.0; let cachedBatches = {};
    const MAG_WIDTH = 220, MAG_HEIGHT = 160, MAG_ZOOM = 2.5, LONG_PRESS_MS = 300;
    let magnifierActive = false, longPressTimer = null, lastMouse = { x: 5, y: 5 }, rafId = null;

    // --- DOM元素获取 ---
    const radarCanvas = document.getElementById('radar-canvas'), radarCtx = radarCanvas.getContext('2d');
    const magnifierCanvas = document.getElementById('magnifier-canvas'), magnifierCtx = magnifierCanvas.getContext('2d');
    const scatterCanvas = document.getElementById('scatter-canvas'), scatterCtx = scatterCanvas.getContext('2d');
    const sourceSelect = document.getElementById('sourceSelect');
    const batchSelect = document.getElementById('batchSelect');
    const addButton = document.getElementById('addButton');
    const clearButton = document.getElementById('clearButton');
    const statusBar = document.getElementById('statusBar');
    const scaleRange = document.getElementById('scaleRange'), scaleValue = document.getElementById('scaleValue');
    const trainPathInput = document.getElementById('trainPathInput');
    const customerPathInput = document.getElementById('customerPathInput');
    const updatePathsButton = document.getElementById('updatePathsButton');

    // --- 绘图与数据更新函数 ---
    function resizeCanvases() { radarCanvas.width = radarCanvas.offsetWidth; radarCanvas.height = radarCanvas.offsetHeight; scatterCanvas.width = scatterCanvas.offsetWidth; scatterCanvas.height = scatterCanvas.offsetHeight; magnifierCanvas.width = MAG_WIDTH; magnifierCanvas.height = MAG_HEIGHT; }

    // --- [重点修改] drawRadar 函数 ---
    function drawRadar() {
        const centerX = radarCanvas.width / 2;
        const centerY = radarCanvas.height / 2;
        const radius = Math.min(centerX, centerY) * 0.9;
        radarCtx.clearRect(0, 0, radarCanvas.width, radarCanvas.height);
        radarCtx.save();
        
        // 绘制背景
        const rings = 5;
        radarCtx.lineWidth = 1;
        for (let i = 1; i <= rings; i++) {
            radarCtx.beginPath();
            radarCtx.arc(centerX, centerY, radius * (i / rings), 0, 2 * Math.PI);
            radarCtx.strokeStyle = 'rgba(0, 255, 0, 0.18)';
            radarCtx.stroke();
        }
        for (let i = 0; i < 12; i++) {
            radarCtx.save();
            radarCtx.translate(centerX, centerY);
            radarCtx.rotate(i * Math.PI / 6);
            radarCtx.beginPath();
            radarCtx.moveTo(0, 0);
            radarCtx.lineTo(0, -radius);
            radarCtx.strokeStyle = 'rgba(0,255,0,0.12)';
            radarCtx.stroke();
            radarCtx.restore();
        }
        
        // 计算最大距离用于缩放
        let maxDistance = 1;
        Object.values(radarTracks).forEach(track => {
            track.data.forEach(p => { if (p.distance > maxDistance) maxDistance = p.distance; });
        });

        // 绘制所有轨迹
        Object.entries(radarTracks).forEach(([compositeKey, track]) => {
            if (!track.data || track.data.length === 0) return;

            // 绘制轨迹线
            radarCtx.beginPath();
            radarCtx.strokeStyle = track.color;
            radarCtx.lineWidth = 2;
            track.data.forEach((p, index) => {
                const angleRad = p.angle * Math.PI / 180;
                const finalDist = Math.min((p.distance / maxDistance) * radius * radarZoom, radius);
                const x = centerX + finalDist * Math.sin(angleRad);
                const y = centerY - finalDist * Math.cos(angleRad);
                if (index === 0) radarCtx.moveTo(x, y);
                else radarCtx.lineTo(x, y);
            });
            radarCtx.stroke();

            // 绘制点和点的标签
            track.data.forEach((p) => {
                const angleRad = p.angle * Math.PI / 180;
                const finalDist = Math.min((p.distance / maxDistance) * radius * radarZoom, radius);
                const x = centerX + finalDist * Math.sin(angleRad);
                const y = centerY - finalDist * Math.cos(angleRad);
                
                // 画点
                radarCtx.beginPath();
                radarCtx.arc(x, y, 3, 0, 2 * Math.PI);
                radarCtx.fillStyle = track.color;
                radarCtx.fill();

                // [新增] 如果点有标签，则绘制它
                if (p.label) {
                    radarCtx.font = '10px monospace';
                    radarCtx.fillStyle = '#FFFF00'; // 用高亮黄色显示点的标签
                    radarCtx.textAlign = 'center';
                    radarCtx.textBaseline = 'bottom';
                    radarCtx.fillText(p.label, x, y - 5);
                }
            });

            // 绘制轨迹的总标签
            const last = track.data[track.data.length - 1];
            const angleRad = last.angle * Math.PI / 180;
            const finalDist = Math.min((last.distance / maxDistance) * radius * radarZoom, radius);
            const lx = centerX + finalDist * Math.sin(angleRad);
            const ly = centerY - finalDist * Math.cos(angleRad);
            
            radarCtx.font = '14px monospace';
            radarCtx.fillStyle = track.color;
            radarCtx.textAlign = 'left';
            radarCtx.textBaseline = 'bottom';
            const batchId = compositeKey.split('-')[1];
            // [改动] 使用后端传来的 main_label
            const displayText = `批 ${batchId} ${track.main_label || ''}`;
            radarCtx.fillText(displayText, lx + 8, ly - 8);
        });
        radarCtx.restore();
    }
    
    function drawScatterPlot() { scatterCtx.clearRect(0, 0, scatterCanvas.width, scatterCanvas.height); const padding = 80; const plotWidth = scatterCanvas.width - padding * 2; const plotHeight = scatterCanvas.height - padding * 2; scatterCtx.save(); scatterCtx.fillStyle = getCSSVar('--bg-color') || '#000'; scatterCtx.fillRect(0, 0, scatterCanvas.width, scatterCanvas.height); if (!currentScatterData || currentScatterData.length === 0) { scatterCtx.fillStyle = getCSSVar('--primary-color') || 'green'; scatterCtx.textAlign = 'center'; scatterCtx.fillText('请先选择一个批号', scatterCanvas.width / 2, scatterCanvas.height / 2); scatterCtx.restore(); return; } const xs = currentScatterData.map(p => p.x); const ys = currentScatterData.map(p => p.y); const maxX = Math.max(...xs); const minX = Math.min(...xs); const maxY = Math.max(...ys); const minY = Math.min(...ys); const extraX = (maxX - minX) * 0.08 || 1; const extraY = (maxY - minY) * 0.08 || 1; const rangeX = (maxX - minX) + extraX * 2; const rangeY = (maxY - minY) + extraY * 2; const scaleX = plotWidth / rangeX; const scaleY = plotHeight / rangeY; const originX = padding; const originY = scatterCanvas.height - padding; scatterCtx.strokeStyle = 'rgba(0,255,0,0.12)'; scatterCtx.lineWidth = 1; const gridCount = 6; for (let i = 0; i <= gridCount; i++) { const gx = originX + (i / gridCount) * plotWidth; scatterCtx.beginPath(); scatterCtx.moveTo(gx, padding); scatterCtx.lineTo(gx, scatterCanvas.height - padding); scatterCtx.stroke(); const gy = originY - (i / gridCount) * plotHeight; scatterCtx.beginPath(); scatterCtx.moveTo(padding, gy); scatterCtx.lineTo(scatterCanvas.width - padding, gy); scatterCtx.stroke(); } scatterCtx.beginPath(); scatterCtx.moveTo(padding, padding); scatterCtx.lineTo(padding, scatterCanvas.height - padding); scatterCtx.lineTo(scatterCanvas.width - padding + 6, scatterCanvas.height - padding); scatterCtx.strokeStyle = getCSSVar('--primary-color') || '#0f0'; scatterCtx.stroke(); scatterCtx.font = '12px monospace'; scatterCtx.fillStyle = getCSSVar('--primary-color') || '#0f0'; scatterCtx.textAlign = 'right'; scatterCtx.fillText('俯仰 (°)', padding - 8, padding + 10); scatterCtx.textAlign = 'center'; scatterCtx.fillText('距离 (m)', scatterCanvas.width - padding, scatterCanvas.height - padding + 20); scatterCtx.fillStyle = getCSSVar('--highlight-color') || '#ff0'; currentScatterData.forEach(p => { const x = originX + (p.x - minX + extraX) * scaleX; const y = originY - (p.y - minY + extraY) * scaleY; scatterCtx.beginPath(); scatterCtx.arc(x, y, 3, 0, 2 * Math.PI); scatterCtx.fill(); }); scatterCtx.restore(); }
    function formatNumberSafe(v, digits = 2) { const n = parseFloat(v); if (Number.isFinite(n)) { return n.toFixed(digits); } return '-'; }
    function updateTable(data) { const tbody = document.querySelector('#track-table tbody'); tbody.innerHTML = ''; if (!data || data.length === 0) return; data.forEach(row => { const tr = document.createElement('tr'); tr.innerHTML = `<td>${row['点时间'] || '-'}</td><td>${row['批号'] || '-'}</td><td>${formatNumberSafe(row['滤波距离'])}</td><td>${formatNumberSafe(row['滤波方位'])}</td><td>${formatNumberSafe(row['滤波俯仰'])}</td><td>${formatNumberSafe(row['全速度'])}</td>`; tbody.appendChild(tr); }); }
    function getRandomColor() { const letters = '0123456789ABCDEF'; let finalColor = '#'; for (let i = 0; i < 6; i++) { finalColor += letters[Math.floor(Math.random() * 16)]; } return finalColor; }
    
    // --- API 调用函数 ---
    async function loadAndDisplayPaths() { try { const res = await fetch(`${API_BASE}/api/paths`); if (!res.ok) throw new Error('获取路径配置失败'); const paths = await res.json(); trainPathInput.value = paths.TRAIN_ROOT_DIR; customerPathInput.value = paths.CUSTOMER_ROOT_DIR; } catch (e) { statusBar.textContent = `错误: ${e.message}`; statusBar.style.color = getCSSVar('--error-color') || 'red'; } }
    async function handleUpdatePaths() { statusBar.textContent = "正在更新路径并重新扫描..."; statusBar.style.color = getCSSVar('--primary-color') || 'green'; const newTrainPath = trainPathInput.value; const newCustomerPath = customerPathInput.value; try { const res = await fetch(`${API_BASE}/api/paths`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ 'TRAIN_ROOT_DIR': newTrainPath, 'CUSTOMER_ROOT_DIR': newCustomerPath }) }); const data = await res.json(); if (!res.ok) throw new Error(data.error || '更新失败'); await handleScanDataset(); statusBar.textContent = data.message || "路径更新并扫描成功！"; } catch (e) { statusBar.textContent = `路径更新失败: ${e.message}`; statusBar.style.color = getCSSVar('--error-color') || 'red'; } }
    async function handleScanDataset() { statusBar.textContent = "正在扫描数据集..."; statusBar.style.color = getCSSVar('--primary-color') || 'green'; try { const res = await fetch(`${API_BASE}/scan_dataset`); const data = await res.json().catch(() => null); if (res.ok) { statusBar.textContent = (data && data.message) ? data.message : '扫描完成'; statusBar.style.color = (data && data.status === 'error') ? (getCSSVar('--error-color') || 'red') : (getCSSVar('--primary-color') || 'green'); await loadBatchList(); } else { const errMsg = (data && (data.message || data.error)) ? (data.message || data.error) : `扫描失败（状态 ${res.status}）`; throw new Error(errMsg); } } catch (e) { statusBar.textContent = `扫描失败: ${e.message}`; statusBar.style.color = getCSSVar('--error-color') || 'red'; } }
    async function loadBatchList() { try { const res = await fetch(`${API_BASE}/batches`); if (!res.ok) throw new Error('获取批次列表失败'); const data = await res.json(); sourceSelect.innerHTML = '<option value="">选择数据源...</option>'; batchSelect.innerHTML = '<option value="">先选数据源...</option>'; sourceSelect.disabled = true; batchSelect.disabled = true; if (data.sources && Object.keys(data.sources).length > 0) { cachedBatches = data.sources; const sourceNames = { 'train': '训练数据 (TRAIN)', 'customer': '测试数据 (CUSTOMER)' }; Object.keys(cachedBatches).forEach(sourceKey => { if (cachedBatches[sourceKey] && cachedBatches[sourceKey].length > 0) { const opt = document.createElement('option'); opt.value = sourceKey; opt.textContent = sourceNames[sourceKey] || sourceKey; sourceSelect.appendChild(opt); } }); if (sourceSelect.options.length > 1) { sourceSelect.disabled = false; } else { sourceSelect.innerHTML = '<option value="">无可用数据源</option>'; } } else { sourceSelect.innerHTML = '<option value="">无可用数据源</option>'; } } catch (e) { console.error('加载批次列表失败:', e); sourceSelect.innerHTML = `<option value="">加载失败</option>`; } }
    function populateBatchSelect() { const selectedSource = sourceSelect.value; batchSelect.innerHTML = ''; batchSelect.disabled = true; if (selectedSource && cachedBatches[selectedSource]) { const batches = cachedBatches[selectedSource]; batchSelect.innerHTML = '<option value="">选择一个批号...</option>'; if (batches.length > 0) { batches.forEach(batchInfo => { const opt = document.createElement('option'); opt.value = batchInfo.id; opt.textContent = `航迹批号 ${batchInfo.id}`; batchSelect.appendChild(opt); }); batchSelect.disabled = false; } else { batchSelect.innerHTML = '<option value="">此源无批号</option>'; } } else { batchSelect.innerHTML = '<option value="">先选数据源...</option>'; } currentScatterData = []; currentTableData = []; updateTable([]); drawScatterPlot(); }
    async function handleSelectBatch() { const source = sourceSelect.value; const batchId = batchSelect.value; if (!source || !batchId) { currentScatterData = []; currentTableData = []; updateTable([]); drawScatterPlot(); return; } statusBar.textContent = `正在加载批号 ${batchId} (源: ${source})...`; try { const body = JSON.stringify({ batch: batchId, source: source }); const [tableResRaw, pointCoordsRaw] = await Promise.all([ fetch(`${API_BASE}/track_data_table`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body }), fetch(`${API_BASE}/point_coordinates`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body }) ]); const tableRes = await tableResRaw.json().catch(() => ({ error: '解析表格数据失败' })); const pointCoordsRes = await pointCoordsRaw.json().catch(() => ({ error: '解析点迹坐标失败' })); if (tableRes.error || pointCoordsRes.error) throw new Error(tableRes.error || pointCoordsRes.error); currentTableData = tableRes.data || []; updateTable(currentTableData); currentScatterData = (pointCoordsRes.scatter_data || []).map(p => ({ x: parseFloat(p.x) || 0, y: parseFloat(p.y) || 0 })); statusBar.textContent = `已加载批号 ${batchId} 的数据。`; statusBar.style.color = getCSSVar('--primary-color') || 'green'; } catch (e) { statusBar.textContent = `加载批号 ${batchId} (源: ${source}) 失败: ${e.message}`; statusBar.style.color = getCSSVar('--error-color') || 'red'; } finally { drawScatterPlot(); } }
    
    // --- [重点修改] handleAddTrack 函数 ---
    async function handleAddTrack() {
      const source = sourceSelect.value;
      const batchId = batchSelect.value;
      if (!source || !batchId) {
        alert('请先选择一个数据源和批号！');
        return;
      }
      const compositeValue = `${source}-${batchId}`;
      if (radarTracks[compositeValue]) {
        alert(`航迹 ${source} ${batchId} 已添加！`);
        return;
      }

      statusBar.textContent = `正在加载批号 ${batchId} (源: ${source}) 的轨迹数据...`;
      try {
        const body = JSON.stringify({ batch: batchId, source: source });
        // 只需请求 track_coordinates，因为它现在包含了所有需要的信息
        const trackCoordsRaw = await fetch(`${API_BASE}/track_coordinates`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body });
        const trackCoordsRes = await trackCoordsRaw.json().catch(() => ({ error: '解析航迹坐标失败' }));
        if (trackCoordsRes.error) throw new Error(trackCoordsRes.error);

        // 使用后端返回的数据填充雷达轨迹对象
        radarTracks[compositeValue] = {
          data: trackCoordsRes.coordinates || [], // data现在可能包含{distance, angle, label}
          color: getRandomColor(),
          main_label: trackCoordsRes.main_label || '' // 存储主标签
        };

        // 触发一次数据加载，以更新右侧的表格和散点图
        handleSelectBatch(); 
        
        statusBar.textContent = `已成功添加航迹 ${batchId} (源: ${source}) 到雷达显示。`;
        statusBar.style.color = getCSSVar('--primary-color') || 'green';
      } catch (e) {
        statusBar.textContent = `加载批号 ${batchId} (源: ${source}) 失败: ${e.message}`;
        statusBar.style.color = getCSSVar('--error-color') || 'red';
      } finally {
        drawRadar();
      }
    }

    function handleClearTracks() { radarTracks = {}; drawRadar(); statusBar.textContent = "已清除所有雷达轨迹。"; statusBar.style.color = getCSSVar('--primary-color') || 'green'; }
    function activateMagnifier() { magnifierActive = true; magnifierCanvas.style.display = 'block'; function loop() { if (!magnifierActive) return; drawMagnifierFrame(); rafId = requestAnimationFrame(loop); } if (!rafId) loop(); statusBar.textContent = '放大镜已激活（按住左键移动以跟随，松开结束）。'; }
    function deactivateMagnifier() { magnifierActive = false; magnifierCanvas.style.display = 'none'; if (rafId) { cancelAnimationFrame(rafId); rafId = null; } statusBar.textContent = '放大镜已关闭。'; }
    function drawMagnifierFrame() { const rect = radarCanvas.getBoundingClientRect(); const mx = lastMouse.x - rect.left; const my = lastMouse.y - rect.top; const sw = MAG_WIDTH / MAG_ZOOM; const sh = MAG_HEIGHT / MAG_ZOOM; let sx = mx - sw / 2; let sy = my - sh / 2; sx = Math.max(0, Math.min(sx, radarCanvas.width - sw)); sy = Math.max(0, Math.min(sy, radarCanvas.height - sh)); try { magnifierCtx.clearRect(0, 0, MAG_WIDTH, MAG_HEIGHT); magnifierCtx.imageSmoothingEnabled = true; magnifierCtx.drawImage(radarCanvas, sx, sy, sw, sh, 0, 0, MAG_WIDTH, MAG_HEIGHT); magnifierCtx.strokeStyle = 'rgba(0,255,0,0.9)'; magnifierCtx.lineWidth = 1; magnifierCtx.beginPath(); magnifierCtx.moveTo(MAG_WIDTH / 2, 0); magnifierCtx.lineTo(MAG_WIDTH / 2, MAG_HEIGHT); magnifierCtx.moveTo(0, MAG_HEIGHT / 2); magnifierCtx.lineTo(MAG_WIDTH, MAG_HEIGHT / 2); magnifierCtx.stroke(); magnifierCtx.strokeStyle = 'rgba(0,255,0,0.95)'; magnifierCtx.lineWidth = 2; magnifierCtx.strokeRect(0.5, 0.5, MAG_WIDTH - 1, MAG_HEIGHT - 1); } catch (e) { console.warn('magnifier draw error', e); } const offset = 16; const containerRect = document.querySelector('.radar-container').getBoundingClientRect(); let left = lastMouse.x + offset; let top = lastMouse.y + offset; if (left + MAG_WIDTH > containerRect.right) { left = lastMouse.x - offset - MAG_WIDTH; } if (top + MAG_HEIGHT > containerRect.bottom) { top = lastMouse.y - offset - MAG_HEIGHT; } magnifierCanvas.style.left = (left - containerRect.left) + 'px'; magnifierCanvas.style.top = (top - containerRect.top) + 'px'; }
    function onRadarMouseDown(e) { if (e.button !== 0) return; lastMouse = { x: e.clientX, y: e.clientY }; longPressTimer = setTimeout(() => { activateMagnifier(); }, LONG_PRESS_MS); }
    function onRadarMouseMove(e) { lastMouse = { x: e.clientX, y: e.clientY }; }
    function onRadarMouseUpOrLeave(e) { if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; } if (magnifierActive) { deactivateMagnifier(); } }
    
    // --- 事件绑定与初始化 ---
    function init() {
      resizeCanvases(); drawRadar(); drawScatterPlot();
      loadAndDisplayPaths();
      updatePathsButton.addEventListener('click', handleUpdatePaths);
      addButton.addEventListener('click', handleAddTrack);
      clearButton.addEventListener('click', handleClearTracks);
      window.addEventListener('resize', () => { resizeCanvases(); drawRadar(); drawScatterPlot(); });
      sourceSelect.addEventListener('change', populateBatchSelect);
      batchSelect.addEventListener('change', handleSelectBatch);
      radarCanvas.addEventListener('mousedown', onRadarMouseDown);
      window.addEventListener('mousemove', onRadarMouseMove);
      window.addEventListener('mouseup', onRadarMouseUpOrLeave);
      radarCanvas.addEventListener('mouseleave', onRadarMouseUpOrLeave);
      scaleRange.addEventListener('input', () => { const val = parseFloat(scaleRange.value) || 1.0; radarZoom = val; scaleValue.textContent = `缩放: ${val.toFixed(2)}×`; drawRadar(); });
      handleScanDataset();
    }
    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>